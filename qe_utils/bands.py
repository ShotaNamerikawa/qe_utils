import os
import math
import numpy as np
import re
from pathlib import Path
from numpy.typing import NDArray
from qe_utils.io_file import IOFiles
import matplotlib.pyplot as plt

from qe_utils.pwx_in import PWxIn

class BandxOut:
    """parse the output of bands.x
    """
    def __init__(self, bands_out:str):
        raise NotImplementedError("")

class Filband:
    """read data from filband of bands.x
    """
    def __init__(self, file:str = "bands.out"):
        """
        Parameters
        ----------
        filband_file : str, optional
            filband parameter in the input file of bands.x, by default "bands.out"
        """
        self.file:str = file
        print("read filband from {}".format(self.file))
        self.read()
        
    @classmethod
    def from_iofiles(self,iofiles:IOFiles):
        raise NotImplementedError("from_iofiles is not implemented.")
        
    def read(self):
        """read filband.
        """
        assert os.path.isfile(self.file), "filband file, {} not found".format(self.file)
        with open(self.file) as fp:
            first_line = fp.readline()
            self.num_band:int = int(first_line.split()[2].strip(",")) # the number of bands.
            self.num_k:int = int(first_line.split()[4]) # the number of kpoints
            self.k_list:NDArray = np.zeros([self.num_k,3]) # kpoints list at which band energies are calculated.
            self.bands_en:NDArray = np.zeros([self.num_k,self.num_band]) # band energies
            num_line_for_one_k = math.ceil(self.num_band/10)+1
            lines = fp.readlines()
            for indk in np.arange(self.num_k):
                self.k_list[indk] = np.array(lines[indk*num_line_for_one_k].strip("\n").split(),dtype=np.float64)
                #FIXME: the performance of the code below might not be good.
                bands_en = []
                for line in lines[indk*num_line_for_one_k+1:(indk+1)*num_line_for_one_k]:
                    bands_en += [float(value) for value in line.strip("\n").split()]
                self.bands_en[indk] = bands_en 
                
    @property 
    def e_max(self):
        """the maximum energy.

        Returns
        -------
        float
        """
        if not hasattr(self, "_e_max"):
            self._e_max = np.max(self.bands_en)
        return self._e_max
    
    @property 
    def e_min(self):
        """the minimum energy

        Returns
        -------
        float
        """
        if not hasattr(self, "_e_min"):
            self._e_min = np.min(self.bands_en)
        return self._e_min
    
    @property
    def bands_en(self):
        """energy of bands of at all kpoints in nscf (shape = (num_k, num_bands)).
        """
        return self._bands_en
    
    @bands_en.setter
    def bands_en(self, bands_en:NDArray):
        self._bands_en = bands_en
        
    def get_filbandgnu(self):
        """get Filbandgnu consistent with filband.
        """
        return Filbandgnu(f"{self.file}.gnu", self.num_k, self.num_band)
        
    def __str__(self):
        print("""
              num_k   :{}
              num_band:{}
              e_min   :{}
              e_max   :{}
              """.format(self.num_k, self.num_band, self.e_min, self.e_max))
        
class Filbandgnu:
    """read data from filband.gnu generated by bands.x
    """
    def __init__(self, file:str|Path, num_k:int, num_band:int):
        self.file = file
        self.num_k = num_k
        self.num_band = num_band
        self.read()
        
    @classmethod
    def from_Filband(cls, filband:Filband):
        file = f"{filband.file}.gnu"
        nk = filband.num_k
        num_band = filband.num_band
        return cls(file, nk, num_band)
        
    def read(self):
        self.ek = np.zeros([self.num_band, self.num_k,2]) # [i,j,0] is kpath norm [i,j,1] is energy
        iband = 0
        ik = 0
        with open(self.file) as fp:
            while True:
                line = fp.readline()
                if not line:
                    break
                if not line.strip():
                    iband += 1
                    ik = 0
                else:
                    self.ek[iband,ik,:] = [float(num) for num in line.split()] # FIXME: kpoints is the same for all bands.
                    ik += 1
                    
    def plot(self, pwxin:PWxIn|None = None, highlight_bands:list = [], savefig:str|None = None, show:bool = False, fermi:float|None = None):
        """plot energy bands alogn k-path
        
        TODO: add a method to read high symmetry kpoints from the output of bands.x

        Parameters
        ----------
        pwxin : _type_, optional
            _description_, by default None
        """
        fig, ax = plt.subplots()
        for i in range(self.ek.shape[0]):
            ax.plot(self.ek[i,:,0], self.ek[i,:,1] - fermi if fermi else self.ek[i,:,1], color = "red" if i in highlight_bands else "black")
        if pwxin:
            if not re.match(r"bands", pwxin.calculation, flags = re.IGNORECASE):
                raise ValueError("given PWxIn is not for bands.x.")
            else:
                xlabels = []
                xpindex = [0]
                xpindex_ind = 0
                for i in range(len(pwxin.high_sym_labels)):
                    inc = pwxin.high_sym_labels[i][-1]
                    if i == len(pwxin.high_sym_labels) - 1:
                        xlabels.append(pwxin.high_sym_labels[i][0])
                        continue
                    if inc == 0:
                        xlabels[xpindex_ind-1] = f"{xlabels[xpindex_ind-1]}|{pwxin.high_sym_labels[i][0]}"
                        xpindex[xpindex_ind] += 1
                    else:
                        xlabels.append(pwxin.high_sym_labels[i][0])
                        xpindex.append(xpindex[xpindex_ind] + inc)
                        xpindex_ind += 1
                b = self.ek[0,xpindex,0]
                ax.set_xticks(self.ek[0,xpindex,0],labels=xlabels) #xpoints must be norm!
                for index in xpindex:
                    ax.axvline(self.ek[0,index,0], color = "black", lw=1)
            ax.set_ylabel("Energy [eV]")
        if savefig:
            plt.savefig(savefig)
        if show:
            plt.show()